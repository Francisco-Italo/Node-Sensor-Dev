#include <msp430.h> 

/**
 * General use
 */
unsigned char slaveAddress, rw;

/**
 * Accel & Gases variables
 */
unsigned int xAccel;
unsigned int yAccel;
unsigned int zAccel;

unsigned char RX_Data[6];
unsigned char TX_Data[2];
unsigned char RX_ByteCtr;
unsigned char TX_ByteCtr;

unsigned int co2Lvl;
unsigned int tvocLvl;

/**
 * MPU-6050 & CCS811 relevant register addresses
 */
const unsigned char MPU_ADDR     = 0x68;      // ADO = GND. Else, 0x69
const unsigned char PWR_MGMT_1   = 0x6B;
const unsigned char ACCEL_XOUT_H = 0x3B;

const unsigned char CCS811_ADDR = 0x5A;
const unsigned char CCS811_MEAS_MODE = 0x01;
const unsigned char CCS811_ALG_RESULT_DATA = 0x02;

/**
 * Prototypes
 */
void acc_setup(void);
void gas_setup(void);
void acc_comm(void);
void gas_comm(void);
void i2c_conf(void);
void i2c_trans(unsigned char, unsigned char, unsigned char);

/**
 * Main function
 */
int main(void)
{
    WDTCTL = WDTPW | WDTHOLD;	// stop watchdog timer
	
	i2c_conf();

	acc_setup();
	gas_setup();

	while(1)
	{
	    acc_comm();
	    gas_comm();

	    __delay_cycles(100000);
	}
}
//-------------------------------------------------------------------------------------------------//
// Accelerometer routines
//-------------------------------------------------------------------------------------------------//
/**
 * MPU setup
 */
void acc_setup()
{
    // Wake up the MPU-6050
    slaveAddress = MPU_ADDR;
    TX_Data[1] = PWR_MGMT_1;
    TX_Data[0] = 0x08;      // Set 8 MHz clock; disable temperature sensor
    TX_ByteCtr = 2;
    rw = 1;
    i2c_trans(slaveAddress, rw, TX_ByteCtr);
    __delay_cycles(32000);                // According to datasheet, hold ~30 ms
                                            // Because of gyroscope based clock oscillator
}
/**
 * Communication with accelerometer device
 */
void acc_comm()
{
    // I2C Transaction
    slaveAddress = MPU_ADDR;            // Register pointing
    TX_Data[0] = ACCEL_XOUT_H;          // First address of the set
    TX_ByteCtr = 1;
    rw = 1;
    i2c_trans(slaveAddress, rw, TX_ByteCtr);
    RX_ByteCtr = 6;                     // Read six bytes of data
    rw = 0;
    i2c_trans(slaveAddress, rw, RX_ByteCtr);

    xAccel  = RX_Data[5] << 8 | RX_Data[4];
    yAccel  = RX_Data[3] << 8 | RX_Data[2];
    zAccel  = RX_Data[1] << 8 | RX_Data[0];
}
//-------------------------------------------------------------------------------------------------//
// Gases sensor routines
//-------------------------------------------------------------------------------------------------//
/**
 * CCS811 setup
 */
void gas_setup()
{
    slaveAddress = CCS811_ADDR;
    TX_Data[1] = CCS811_MEAS_MODE;
    TX_Data[0] = 0x10;                  // Put CCS to normal mode, no interrupt enable
    TX_ByteCtr = 2;
    rw = 1;
    i2c_trans(slaveAddress, rw, TX_ByteCtr);
}
/**
 * Communication with gases sensor
 */
void gas_comm()
{
    // Read data
    slaveAddress = CCS811_ADDR;
    TX_Data[0] = CCS811_ALG_RESULT_DATA;
    TX_ByteCtr = 1;
    rw = 1;
    i2c_trans(slaveAddress, rw, TX_ByteCtr);
    RX_ByteCtr = 8;                  // Reading operation of environment data register
    rw = 0;
    i2c_trans(slaveAddress, rw, RX_ByteCtr);

    co2Lvl = (RX_Data[0] << 8 | RX_Data[1]);
    tvocLvl = (RX_Data[2] << 8 | RX_Data[3]);
}
//-------------------------------------------------------------------------------------------------//
// I2C related routines
//-------------------------------------------------------------------------------------------------//
/**
 * Configuration of I2C module
 */
void i2c_conf(void)
{
    // I2C pins configuration
    P1SEL0 |= BIT2 | BIT3;

    // Disable the GPIO power-on default high-impedance mode to activate
    // previously configured port settings
    PM5CTL0 &= ~LOCKLPM5;

    // Configure USCI_B0 for I2C mode
    UCB0CTLW0 |= UCSWRST;                    // Software reset enabled

    UCB0CTLW0 |= UCMODE_3 | UCMST;          // I2C mode, Master mode, SMCLK
    UCB0CTLW0 |= UCSSEL__SMCLK | UCSYNC;    // Use SMCLK as clock source, sync
    UCB0CTLW1 |= UCASTP_2;                  // Automatic STOP generated by UCB0TBCNT
    UCB0BR0 = 0x000A;                       // baudrate = SMCLK / 10 = ~100 kHz

    UCB0CTLW0 &= ~UCSWRST;                   // Disable SW reset
}
/**
 * I2C transaction function
 */
void i2c_trans(unsigned char addr, unsigned char rw, unsigned char byteCtr)
{
    while(UCB0CTL1&UCTXSTP);

    UCB0CTLW0 |= UCSWRST;
    UCB0I2CSA = addr;                   // Slave address
    UCB0TBCNT = byteCtr;
    UCB0CTLW0 &= ~UCSWRST;
    UCB0IE |= UCTXIE0 | UCRXIE0 | UCBCNTIE;

    (rw) ? (UCB0CTL1 |= UCTR):(UCB0CTL1 &= ~UCTR);  // Clear -> receiver / Set -> transmitter
    UCB0CTL1 |= UCTXSTT;

    __bis_SR_register(LPM0_bits|GIE);   // Enter LPM0 w/ interrupt
}
/**
 * UCB0 ISR
 */
#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
#pragma vector = USCI_B0_VECTOR
__interrupt void USCIB0_ISR(void)
#elif defined(__GNUC__)
void __attribute__ ((interrupt(USCI_B0_VECTOR))) USCIB0_ISR (void)
#else
#error Compiler not supported!
#endif
{
  switch(__even_in_range(UCB0IV, USCI_I2C_UCBIT9IFG))
  {
      case USCI_I2C_UCNACKIFG:
          UCB0CTL1 |= UCTXSTT;                      //resend start if NACK
          break;
      case USCI_I2C_UCRXIFG0:
          RX_Data[--RX_ByteCtr] = UCB0RXBUF;  // Get received byte
          break;
      case USCI_I2C_UCTXIFG0:
          UCB0TXBUF = TX_Data[--TX_ByteCtr];  // Passes byte to transmit buffer
          break;
      case USCI_I2C_UCBCNTIFG:
          UCB0CTL1 |= UCTXSTP;
          __bic_SR_register_on_exit(CPUOFF);  // Exit LPM0
          break;
  }
}
// End program
